/*************************************************************************
 * PositionCalibration.cpp script can be used to alpha calibrate position*
 * for the front strips of position sensitive SX3 detectors.             *
 *                                                                       *
 * Event by event pedestal substraction is done and gains generated by   *
 * Gainmatch.cpp for different strips are applied. Energy calibration    *
 * parameters are also applied from SX3EnCal.dat. Position = (L-R)/E is  *
 * calculated for highest energy alpha line and projected to 1D-position *									 
 * histogram. The ends (x1 & x2)are calculated by taking x-values at 50% *
 * of y-max. Then x1 and x2 are stored in PosCal.dat file.               *
 * 			                				 *									 
 * To see if x1 and x2 are correct, SX3PosCal.root file is created in    *
 * the Output directory. Encalled.root file is also created which has    *
 * calibrated EvP histograms.    				         *
 *************************************************************************/


#define Analysis_cxx

#include "Analysis.h"


#include <string>
#include <fstream>

TChain* MakeChain();

int main() {
    TChain *chain = MakeChain();

    Analysis t(chain);
    t.Loop();
}

TChain* MakeChain() {
    auto *chain = new TChain("data");
    TString PathToFiles = "/mnt/e/goddessSort-master/Output/Run";

  
    //Choose your detector
    chain->Add(PathToFiles + "0446.root"); //SX3 Upstream 0-3
    //chain->Add(PathToFiles + "0448.root"); //SX3 upstream 2-4 (detector #5 is empty. I am calibrating #4 with this file)
    //chain->Add(PathToFiles + "0449.root"); // SX3 upstream 6-8
    //chain->Add(PathToFiles + "0447.root"); //SX3 upstream 8-10 (I am calibrating #9 and #10 with this file. Also, #11 is empty)



    return chain;
}

void Analysis::Loop() {
    if (fChain == 0) return;

    Long64_t nentries = fChain->GetEntriesFast();
    int prevRunNumber = -1;



	//Open the pedestals File 
	std::ifstream file;
	file.open("SX3pedestals.dat");
	Double_t LeftPed[192] = {0};
	Double_t RightPed[192] = {0};
	for (Int_t i = 0; i<192;i++){
		file >> LeftPed[i] >> RightPed[i];		
	}

	//Open the gains file
	std::ifstream gainfile;
	gainfile.open("/mnt/e/Analysis/SX3 Calibration/SX3gains.dat");
	Double_t Gains[192] = {0}; 
	for (Int_t i=0; i<192; i++){
			gainfile >>Gains[i];
			//std::cout << Gains[2] << std::endl;
	}

	//Open the Energy Calibration file
	std::ifstream EnCalfile;
	EnCalfile.open("/mnt/e/Analysis/SX3 Calibration/SX3EnCal.dat");
	Double_t EnCalSlope[192] = {0};
	Double_t EnCalIntercept[192] = {0}; 
	for (Int_t i=0; i<192; i++){
			EnCalfile >>EnCalSlope[i] >> EnCalIntercept[i];
			//std::cout << EnCalSlope[2] << " " << EnCalIntercept[3] << std::endl;
	}
	
	
	//Define Histograms here
	//Histograms without the gains applied
	TH1F *SX3_PosCal[12][4]; // Position Histogram for the Calibration of the Position
	TH2F *SX3_EvP[12][4]; //Energy calibrated Energy vs Position Histogram 
	for (Int_t i=0; i<12; i++){ // Loop over detectors
		for (Int_t j=0; j<4; j++){ //Loop over the strips
			//for (Int_t k=0; k<4; k++){ // Loop over the backs
				std::string nameSX3_PosCal = Form("SX3_PosCal_Det%i_Strip_%i",i,j);
				std::string nameSX3_EvP = Form("SX3_EvP_Det%i_Strip_%i",i,j);
				SX3_PosCal[i][j] = new TH1F(nameSX3_PosCal.c_str(), "SX3 Position Spectrum for Front Side Position Calibration",1000,-1,1);
				SX3_EvP[i][j] = new TH2F(nameSX3_EvP.c_str(),"SX3 E v P Histogram for Front side", 1000,-1,1,1000,0,12000);
			//}//End of loop over backs
		}//End of Loop over Fronts
	}//End of Loop over Detectors*/



	//Create Output File   
	TFile* outputFile = new TFile("/mnt/e/Analysis/SX3 Calibration/Output/PosCal.root", "recreate");
	TFile* outputFile2 = new TFile("/mnt/e/Analysis/SX3 Calibration/Output/EnCalled.root", "recreate");


    Long64_t nbytes = 0, nb = 0;
    for (Long64_t jentry=0; jentry<nentries;jentry++) {
        Long64_t ientry = LoadTree(jentry);
        if (ientry < 0) break;
        nb = fChain->GetEntry(jentry);   nbytes += nb;

		
	   	
		//Loop over the Multiplicity
		for(Int_t j=0; j<SX3Mul; j++){
			
			//Without gains (Pedestals Substracted)
			Float_t SX3RawStripRight = SX3StripRightADC[j] - RightPed[(SX3Det[j]*16)+(SX3Strip[j]*4)+(SX3Sector[j])];
			Float_t SX3RawStripLeft = SX3StripLeftADC[j] - LeftPed[(SX3Det[j]*16)+(SX3Strip[j]*4)+(SX3Sector[j])];
		
			//Gain Adjustement and Calibration Applied	
			Float_t RawStripLeft = SX3RawStripLeft; 
			Float_t RawStripRight = -1. * SX3RawStripRight * (Gains[(SX3Det[j]*4)+(SX3Strip[j])]); //Gains applied 

			Float_t RawEnergy = RawStripRight + RawStripLeft; // Gain matched Energy (No calibration though)
			Float_t Energy = RawEnergy * EnCalSlope[(SX3Det[j]*16)+(SX3Strip[j]*4)+(SX3Sector[j])] + EnCalIntercept[(SX3Det[j]*16)+(SX3Strip[j]*4)+(SX3Sector[j])]; //Energy Calibrated
			Float_t RawPosition = ((RawStripRight - RawStripLeft) / Energy ); // Gain matched Position( Energy has been Calibrated but No Calibration on Left and Right though)


			//Filling the histograms here
			if (SX3Upstream[j] && Energy > 8000.)SX3_PosCal[SX3Det[j]][SX3Strip[j]]->Fill(RawPosition);
			if (SX3Upstream[j] && Energy > 8000.)SX3_EvP[SX3Det[j]][SX3Strip[j]]->Fill(RawPosition,Energy);		
	
		}// End of the multiplicity Loop	
    }// End of event by event analysis

    //Cleaning the dat file to save the Position Calibration info
    std::ofstream pfile;
    pfile.open("/mnt/e/Analysis/SX3 Calibration/SX3PosCal.dat", std::ofstream::out | std::ofstream::trunc);
    pfile.close();
    
    //Define the fit function here;
    TF1* line = new TF1("line", "[0]",-1,1);
    Float_t xleft;  //This is the left point on x axis in Position spectrum that we're trying to find
    Float_t xright; //This is the right point on x axis in Position spectrum that we're trying to find
	
    outputFile->cd();

    //Looping over the position spectrum to fit and do all sorts of calculations to find the xleft and xright
    for (Int_t i=0; i<12; i++){ //Loop over detectors
   	for (Int_t j=0; j<4; j++){ //Loop over Strips
		//for (Int_t k=0; k<4;k++){//Loop over back sides
			Int_t n = (SX3_PosCal[i][j]->GetXaxis())->GetNbins(); //Total number of bins
			Float_t yvalue[n] = {0};
			Float_t xvalue[n] = {0};
 			Int_t MaxBin = SX3_PosCal[i][j]->GetMaximumBin(); //This gives the bin with maximum y value
			Float_t ymax = SX3_PosCal[i][j]->GetBinContent(MaxBin); //This gives the y value at that bin
			Float_t xmax = ((TAxis*)SX3_PosCal[i][j]->GetXaxis())->GetBinCenter(MaxBin); //This gives the x value at that bin
			//std::cout << xmax << '\t' << ymax << std::endl;
			line->SetParLimits(0,ymax-80,ymax+80);
			SX3_PosCal[i][j]->Fit("line","Q","",xmax-0.09,xmax+0.09);
			Float_t y = 0.5 * (line->GetParameter (0)); //Getting 50% of the ymax
			//std::cout << y << std::endl;
			
			//Looping over all the bins 
			for (Int_t p=0; p<n; p++){
				yvalue[p] = SX3_PosCal[i][j]->GetBinContent(p); // This gives y value at each bin
				xvalue[p] = ((TAxis*)SX3_PosCal[i][j]->GetXaxis())->GetBinCenter(p);
				
				//Calculate x-left for left side of position spectrum
				if (p>0 && yvalue[p-1]<y && yvalue[p]>y){
					Float_t m = (yvalue[p]-yvalue[p-1])/(xvalue[p]-xvalue[p-1]); //calculating slope from the value greater than and smaller than y
					xleft = ((y-yvalue[p-1])/m) + xvalue[p-1];
					//std::cout << i << '\t' << j << '\t' << ymax << '\t' << y << '\t' << xleft << std::endl;
					break;
				}

			}
			for (Int_t p=n; p-- >0;){ //Looping over the bins is descending order
				yvalue[p] = SX3_PosCal[i][j]->GetBinContent(p); // This gives y value at each bin
				xvalue[p] = ((TAxis*)SX3_PosCal[i][j]->GetXaxis())->GetBinCenter(p);
				
				//std::cout << n << '\t' << p << std::endl;
				if (yvalue[p]>y && yvalue[p+1]<y){
					Float_t m = (yvalue[p+1]-yvalue[p])/(xvalue[p+1]-xvalue[p]); //Calculating slope from the value greater than and smaller than y 
					xright = ((y-yvalue[p])/m) + xvalue[p];
					//std::cout << i << '\t' << j << '\t' << ymax << '\t' << y << '\t' << xright <<std::endl;
					break;

				}
			}//End of loop over all the bins

			//std::cout << xleft<< '\t' << xright << std::endl;

			std::ofstream pfile;
			pfile.open ("/mnt/e/Analysis/SX3 Calibration/SX3PosCal.dat",std::ofstream::app);
			pfile << xleft << '\t' << xright << std::endl;
			pfile.close();
			SX3_PosCal[i][j]->Write();   
  		//} // End of loop over back side
	}//End of loop over strips
    }//End of loop over detectors
      

    outputFile->Close();
    outputFile2->cd();
    for (Int_t i=0;i<12;i++){
	for (Int_t j=0;j<4;j++){
		SX3_EvP[i][j]->Write(); //Energy calibrated E v P histogram
	}

    }
    outputFile2->Close();
}














